Bitcoin Internals, Part 1 – Coding Enter your email Address Skip to content Coding Software is hard Search Search Search … Coding Software is hard Search Search Search … Search Search … Home » Bitcoin » Bitcoin Internals, Part 1 Bitcoin Bitcoin Internals, Part 1 Published 3 October, 2017-Updated 11 April, 2023|5 comments Tweet 13 minutes read After a long hiatus I’ve decided to revive this blog by writing a series of blog posts related to Bitcoin and it’s architecture
. For the most part the articles will discuss certain structures from Bitcoin’s GitHub repository, but I’ll try to explain them without resorting to tech-savvy terms. Some of you might already have invested in Bitcoin or related cryptos but I am pretty sure that most of you have never looked deeper into the architecture than the usual media outlets do. I suppose that you have heard something about the “blockchain” or “distributed ledger”
. I suppose that you have heard something about the “blockchain” or “distributed ledger”. And of course, there’s no shortage of pundits explaining the \(dis\)advantages of Bitcoin and how it’ll \(destroy?\)/\(revolutionize?\) everything. All in all, the media circus is dutifully delivering the needed injections of \(mis\)information just like with any other hype. And yes, Bitcoin is a hype, no matter how much one might \(dis\)like it
. And yes, Bitcoin is a hype, no matter how much one might \(dis\)like it. A hype is a product of hysteria multiplied by lack of deeper understanding. However, the thing being hyped doesn’t have to be something negative or harmful, just like the Web in the 90es wasn’t something of low value. But the hype surrounding those things can damage the reputation of future products and services. And it usually takes some time to recover financially and regain public trust
. And it usually takes some time to recover financially and regain public trust. This happened with the Web before and I assume it’ll happen with the cryptocurrency market as well. An individual can’t stop the hype but every individual should accumulate enough knowledge to make him/herself strong enough to withstand the virus of hype. There’s no accumulation of capital without accumulation of knowledge in the first place
. There’s no accumulation of capital without accumulation of knowledge in the first place. It’s no wonder that many follow anonymous “financial experts” on Twitter or Reddit or even pay to join their groups to get “secret knowledge” on how to beat the market. However, I’m not judging anyone of those who follow false prophets. We are free to choose. But, moving in an area without deeper knowledge about the things surrounding you is a recipe for disaster. A very personal disaster
. A very personal disaster. No wonder so many are ready to pay lots of bitcoins to join shady “expert Twitter groups”. The strongest emotion is fear and its strongest variant is the fear of the unknown.Â Â It’s all in the Blocks There’s no Bitcoin without the Blockchain, just like there’s no Blockchain without its Blocks. We’ll try to understand what a Block is by examining it’s structure from the Bitcoin project itself
. We’ll try to understand what a Block is by examining it’s structure from the Bitcoin project itself. Technically savvy readers should use the original C++ source code while I’ll be presenting simplified versions throughout the text. In future articles I’ll be also using other programming languages like Python to describe certain concepts. But for now we’ll stick to the dual C++ representation: simplified C++ here and links to real C++ from the Bitcoin repository
. But for now we’ll stick to the dual C++ representation: simplified C++ here and links to real C++ from the Bitcoin repository. Basically, every Block contains a BlockHeader and a vector of Transactions. A vector is just a mathematical way to describe a set of values that belong to a certain category. Just imagine an ordered collection of things that belong to a category called Transactions
. Just imagine an ordered collection of things that belong to a category called Transactions. Each of those values would have certain features that make them distinguishable from other values belonging to other categories. This is one of the many ways how machines select values. Regarding Bitcoin a Transaction represents aÂ Transfer of ValueÂ from one address to another. And to be accepted as valid a Transaction must find its way into a Block
. And to be accepted as valid a Transaction must find its way into a Block. There are many Transactions trying to reach the Blockchain, but not all of them can be processed at the same time or just a second later. Therefore, Bitcoin participants who create Blocks continuously receive incoming Transactions and some of them land into the next Block while others have to wait for the next Block to be generated
. It depends on different factors like offered transaction fees \(the higher the fee you’re willing to pay the faster you’ll get into the next block\), available transaction memory pool, the size of the Block itself and so on. Transactions can be of different type which we’ll describe in later articles, but for now, we should simply keep in mind that a Block contains a BlockHeader and a collection of Transactions.Â Now let’s take a closer look at the BlockHeader
. We see that aÂ BlockHeaderÂ is just another classÂ that comprises of severalÂ members. And by the way,Â classÂ is a term used very often by many programming languages to describe things we’re dealing with within a certain domain. Here our domain is Bitcoin and therefore we define our world as something that’s naming things as Blockchain, Blocks, Headers, Transactions, Addresses and so on. We classify those things by giving them meaningful names and assigning them properties
. We classify those things by giving them meaningful names and assigning them properties. This is why we use classes when we code software. It helps us create and maintain an order to better control our world. Therefore, we have classified this thing called “Blockchain” asÂ a chain of Blocks. And to make it resemble a real chain we define additional things to function as its building blocks \(pun intended\). However, I don’t want to drain too much of your energy by throwing all this programming stuff at you
. However, I don’t want to drain too much of your energy by throwing all this programming stuff at you. But I hope it was sufficient enough to explain some basic coding concepts clearer.Â Â Hashing and Chaining BlockHeaders carry six members that support core tenets of the Blockchain philosophy. First, BlockHeaders make the chaining of blocks possible. Second, they make sure no one can easily manipulate the blockchain entries, for example by replacing older blocks or changing transactions
. Without BlockHeaders the Blockchain couldn’t fulfill it’s most important promise of preventing the double spending problem. Let’s examine the members of BlockHeader class to get a deeper understanding of how hashing and block chaining works
. Name Role Type Version Version number Â numeric PreviousBlockHash Contains the Block-Hash of the preceding Block Â alphanumeric MerkleRootHash Contains the Root Hash that comprises of all subordinated Transaction Hashes within the current Block Â alphanumeric Timestamp Creation Timestamp in Unix format Â numeric TargetToBeSolved Contains an specifically encoded “target value” that must be used when solving Proof-of-Work problems
. For a block to be accepted in the Blockchain the calculated value must be less or equal than “target value”. Â encoded byte values NonceForProofOfWork A numeric value that must be used to generate random data when solving the Proof-of-Work problem for this Block. Â numeric When a Block comes into existence it’s future place in the Blockchain is determined by the existence of a previous Block that has already found its location on the Blockchain
. Just look at the second member of the class BlockHeader: PreviousBlockHash. Previous what? BlockHash what?Â ðŸ˜¯Â To answer these questions one should first take into account that our Blockchain doesn’t deal with accounts, deposits, withdrawalsÂ etc. It has no mechanisms available to control such classes of objects. There is no source code for class Account or DepositÂ in Bitcoin. Such classes belong to centralized mechanisms our today’s banks use to \(mis\)manage our savings
. Such classes belong to centralized mechanisms our today’s banks use to \(mis\)manage our savings. But how does the Blockchain know which of the Bitcoins belong to me and how much I have to spend or receive, for example? The answer lies in the fundamental rule that the Blockchain “thinks” in transactions only. Because there’s no central management to maintain the equilibrium of inputs and outputs the only available decentralized mechanism is the control of the transaction flow itself
. If you go back and look at the class Block you’ll see that its second member is the collection \(vector\) of Transactions. Now look at the third member of the class BlockHeader: MerkleRootHash. This variable \(yet another term from computing that simply means a thing containing some value\) contains the root of a tree-like structure that comprises of all transactions belonging to this Block
. Just imagine yourself taking a bunch of transactions and combining their hashes into a simple mathematical tree \(displayedÂ upside-down\). TheÂ Merkle Root is a combination of all underlying Transaction-hashes within a Merkle Tree. If you take all transaction hashes from a Block and recursively combine them together you’ll finally end up with a single hash comprising of all preceding hashes. We start at the bottom and generate the first series of hashes
. We start at the bottom and generate the first series of hashes. Then we take those from the first level to generate a new series of hashes until we reach a single hash that’ll constitute our root hash. This final hash is called Merkle Root. And it has one interesting quality: if you change any of the underlying transactions the modifications will ripple through the entire tree effectively changing the root itself. For example, you change some Bitcoin amount within one of the transactions
. For example, you change some Bitcoin amount within one of the transactions. The immediate outcome would be that not only this single transaction hash would change but also all the combined hashes together up to the Merkle Root itself. No change won’t go unnoticed. Therefore, any manipulation will surely provoke the self-preserving nature of the Blockchain that’ll ultimately result in the rejection of the Block containing these changes
. Therefore, a Merkle Tree is not only a very economical way of managing large amounts of data by creating hashes for every transaction, but also a perfect way of taking care that no manipulated blocks could ever reach the Blockchain. Hash all the Transactions Before we continue with hashing and chaining of our Block we should quickly define the process of hashing itself. A hash functionÂ is a function that can map data of arbitrary size to data of fixed size
. A hash functionÂ is a function that can map data of arbitrary size to data of fixed size. Imagine you want to create fingerprints of all the books from a library to make sure your library’s database contains uniquely identifiable entries. There are all sorts of books with different content, lengths, titles, authors, but you want them to have individual hashes comprising of exactly 32 alphanumeric characters. No more no less
. No more no less. To solve such tasks we use hash functions, because they’re capable of consuming input of any lengths \(for example: author info + book content + publication year\) while still providing unique values of a fixed length \(32 alphanumeric characters for each book\). There are many different hash functions available but we won’t go too deep into them for now
. There are many different hash functions available but we won’t go too deep into them for now. Just take into account that you need some mechanism to uniquely fingerprint certain data so that you can later use those hashes as indicators that the original content remained the same. Therefore, a hash serves as a mechanism to check the integrity of data
. Therefore, a hash serves as a mechanism to check the integrity of data. If you think that some content has been changed while you weren’t looking at it, just take its original hash and let the current content run through the hash function. If it returns the same hash-result all is fine. If it doesn’t you can be pretty sure that the original data has been changed. And this is the way Bitcoin clients make sure that no \(un\)intentionally changed data enters the Blockchain
. And this is the way Bitcoin clients make sure that no \(un\)intentionally changed data enters the Blockchain. Each time someone generates a new Block with Transactions in it, all other clients will take this Block-candidate and check the given hashes for validity before allowing it to become part of the Blockchain
. Because all clients contain exact copies of the Blockchain it’s very easy to find out if someone is, for example trying to declare that a certain Transaction wants to move “way too much” Bitcoins to some address. Â Imagine now that after we had created a proper Block all other Blockchain participants have accepted it as valid. Our block would now become a part of the Blockchain and the next block in chain would also need a proper HashPrevBlock
. Our block would now become a part of the Blockchain and the next block in chain would also need a proper HashPrevBlock. Its HashPrevBlock would therefore need the BlockHeader of our own Block to generate this hash.Â It’s easy to recognize that the role of BlockHeader class is two-fold. First, it serves us as a concept to insert values into variables described in the table above
. First, it serves us as a concept to insert values into variables described in the table above. Second, the BlockHeader as a whole will become anÂ input valueÂ of the has-function that generates theÂ next PreviousBlockHash of the Block that follows our own. And by making this possible we let the Blockchain become a properÂ chain of blocks. By letting each block point to its predecessor we generate a back-linked structure where no single element can be manipulated without affecting all others
. A slightest change in some completely unrelated transaction within any of the previous Blocks would provoke a chain reaction that’ll ultimately lead to a Block being rejected by the majority of participants who still follow the unmodified version of the Blockchain. Here’s a link to a nice visual presentation of this mechanism. Conclusion In the world of programming we say: programming is understanding. And I think that the same should apply to the world of finance
. And I think that the same should apply to the world of finance. These days everything runs on software so it’s not a wonder that even our money will become software. Actually, most of our today’s money has already been software for the most part of its existence. However, we now have erected distributed and decentralized systems capable of creating money and money-like things that refuse to be controlled by anyone
. Software systems of that kind can only run autonomously but nevertheless, we, as individuals, should get a more detailed picture of their inner logic. Just like computer literacy is needed to fully participate in pur modern world a certain level of Bitcoin \(or if you will “distributed ledger”\) literacy will be needed to become an independent participant in the financial systems of the future
. In this article we had barely scratched the surface as I’ve deliberately avoided to show more complex things \(“how does a Transaction look like?”\) but I promise you that future articles will contain much more code.Â Â Tweet You may also like Published 8 October, 2017 Bitcoin Internals, Part 2 1 comment In this installment we’ll be talking about Transactions
. As we already know a Bitcoin Block contains a Header and a collection of \[…\] Published 16 November, 2017 Running a full Bitcoin node on Raspberry Pi 3 8 comments In this article we’ll compile and configure a full Bitcoin Core Node that runs on a Raspberry Pi 3. “Raspies” are tiny \[…\] Leave a comment Cancel reply Connect with: Your email address will not be published. Required fields are marked \*Comment \* Name \* Email \* Website Δ This site uses Akismet to reduce spam
. Required fields are marked \*Comment \* Name \* Email \* Website Δ This site uses Akismet to reduce spam. Learn how your comment data is processed.5 thoughts on “Bitcoin Internals, Part 1” 5&nbspcomments; Michael Dance 4 October, 2017, 09:31 For anyone interested, this is one of the best illustrations of each of the concepts described in this article: https://anders.com/blockchain/ Reply brakmic Post author 4 October, 2017, 10:06 Hi Michael, Thanks for the link
. I’ll insert it in the article ðŸ™‚ Regards, Reply TomÃ¡s ConceiÃ§Ã£o 26 June, 2018, 14:07 Hello sir, will you give me permission to use your image depicting a bitcoin blockchain in my internship report? I will link it to this website. Thank you\! Reply brakmic Post author 26 June, 2018, 23:57 Hi, Ok, no problem. Reply Mark Robson 20 July, 2018, 11:34 This article is great\! Thanks for sharing. Really clarified the structure of a block and how transactions get included
. Reply Follow @brakmic December 2024 M T W T F S S 1 2345678 9101112131415 16171819202122 23242526272829 3031 « Sep AIIntro to Semantic Kernel â€“ Part One Intro to Semantic Kernel â€“ Part Two Intro to Semantic Kernel â€“ Part Three Intro to Semantic Kernel â€“ Part Four Intro to Semantic Kernel â€“ Part Five Intro to Semantic Kernel â€“ Addendum AssemblyIntro to Assembly with FASM Intro to Assembly with FASM â€“ Part 2 AngularIntroduction to Angular 2 â€“ Part 1 Introduction to Angular 2 â€“ Part 2
FASM Intro to Assembly with FASM â€“ Part 2 AngularIntroduction to Angular 2 â€“ Part 1 Introduction to Angular 2 â€“ Part 2 Introduction to Angular 2 â€“ Part 3 Introduction to Angular 2 â€“ Part 4 Introduction to Angular 2 â€“ Part 5 Introduction to Angular 2 â€“ Part 6 WebVR with A-Frame & Angular Reactive apps with Angular & ngrx BitcoinBitcoin Internals
, Part 1 Bitcoin Internals, Part 2 Bitcoin node on Raspberry Pi 3 BosqueFirst steps with Bosque First steps with Bosque – Part 2 C++Parallel Computing in Node.js Revisiting HPX Writing HDAs with htmx and C++ High-Perf Computing with HPX Thrill â€“ Big Data with C++ COBOLGnuCOBOL on Windows Data ScienceDS for Losers DS for Losers, 2 DS for Losers, 2 – Addendum DS for Losers, 3 DS for Losers, 4 – Machine Learning DS for Losers, 5 – Spark DataFrames DS for Losers, 6 – Azure ML DS for Losers
, 7 – Using Azure ML Stream Processing with Apache Flink GitGit Workflow under Windows JuliaIntro to Julia Julia Cheat Sheet KeycloakKeycloak Extensions Keycloak Templating Keycloak with PostgreSQL Keycloak with PostgreSQL-HA Automating Keycloak Deployments KubernetesKeycloak with PostgreSQL Keycloak with PostgreSQL-HA PureScriptUsing Web Streams with PS WebApps with PS & RactiveJS Managing AppState with PS & Redux Offline-First with Hoodie & PureScript PythonConsole Twitter Client Ractive.jsRactive.JS
Managing AppState with PS & Redux Offline-First with Hoodie & PureScript PythonConsole Twitter Client Ractive.jsRactive.JS Adaptors Events
, Keypaths & Observers Components with Ractive.JS ScalaScala Monads Scala Crash Course, Pt
. 1 LegalCookie policy \(EU\) Terms & conditions Post navigation Previous post Reactive apps with Angular & ngrx Back to post list Next post Bitcoin Internals, Part 2 Â© 2023 by Harris Brakmic – All rights reserved Manage Cookie Consent We use cookies to optimize our website and our service
. Functional Functional Always active The technical storage or access is strictly necessary for the legitimate purpose of enabling the use of a specific service explicitly requested by the subscriber or user, or for the sole purpose of carrying out the transmission of a communication over an electronic communications network. Preferences Preferences The technical storage or access is necessary for the legitimate purpose of storing preferences that are not requested by the subscriber or user
. Statistics Statistics The technical storage or access that is used exclusively for statistical purposes. The technical storage or access that is used exclusively for anonymous statistical purposes. Without a subpoena, voluntary compliance on the part of your Internet Service Provider, or additional records from a third party, information stored or retrieved for this purpose alone cannot usually be used to identify you
. Marketing Marketing The technical storage or access is required to create user profiles to send advertising, or to track the user on a website or across several websites for similar marketing purposes. Manage options Manage services Manage \{vendor\_count\} vendors Read more about these purposes Accept cookies Deny View preferences Save preferences View preferences \{title\} \{title\} \{title\} Manage consent